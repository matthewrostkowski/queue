class QueuesController < ApplicationController
  before_action :set_queue_session, only: [:show, :start_playback, :stop_playback, :next_track, :queue_state]

  # GET /queue
  def show
    # upcoming queue
    @queue_items = @queue_session.queue_items
                                 .where(played_at: nil)
                                 .order(vote_score: :desc, created_at: :asc)

    # last played / now playing
    @now_playing = @queue_session.queue_items
                                 .where.not(played_at: nil)
                                 .order(played_at: :desc)
                                 .first
  end

  # POST /queue/start_playback
  def start_playback
    # pick next unplayed song by score, mark it playing now
    next_song = @queue_session.queue_items
                              .where(played_at: nil)
                              .order(vote_score: :desc, created_at: :asc)
                              .first

    if next_song
      next_song.update(played_at: Time.current)

      if next_song.preview_url.present?
        render json: {
          success: true,
          song: format_song(next_song),
          message: "Playing #{next_song.title}"
        }
      else
        render json: {
          success: false,
          message: "No preview available for this track"
        }, status: :unprocessable_entity
      end
    else
      render json: {
        success: false,
        message: "Queue is empty"
      }, status: :unprocessable_entity
    end
  end

  # POST /queue/stop_playback
  def stop_playback
    @queue_session.stop_playback! if @queue_session.respond_to?(:stop_playback!)

    render json: {
      success: true,
      message: "Playback stopped"
    }
  end

  # POST /queue/next_track
  def next_track
    next_song = @queue_session.queue_items
                              .where(played_at: nil)
                              .order(vote_score: :desc, created_at: :asc)
                              .first

    if next_song
      next_song.update(played_at: Time.current)

      if next_song.preview_url.present?
        render json: {
          success: true,
          song: format_song(next_song)
        }
      else
        render json: {
          success: false,
          message: "No more tracks in queue with previews"
        }, status: :unprocessable_entity
      end
    else
      render json: {
        success: false,
        message: "No more songs in queue"
      }, status: :unprocessable_entity
    end
  end

  # GET /queue/state (for polling)
  def queue_state
    render json: {
      is_playing: @queue_session.is_playing,
      currently_playing: currently_playing_json,
      queue: upcoming_queue_json
    }
  end

  private

  #
  # session helpers
  #
  def set_queue_session
    @queue_session = current_queue_session || QueueSession.first

    unless @queue_session
      redirect_to root_path, alert: "No active queue session"
    end
  end

  def current_queue_session
    # prefer whatever's in session
    if session[:current_queue_session_id].present?
      return QueueSession.find_by(id: session[:current_queue_session_id])
    end

    # fallback / bootstrap
    @current_queue_session ||= QueueSession.first_or_create!(
      name: "Main Queue",
      is_active: true
    )
  end

  #
  # formatting helpers
  #
  def format_song(song)
    {
      id: song.id,
      title: song.title,
      artist: song.artist,
      cover_url: song.cover_url,
      duration_ms: song.duration_ms,
      preview_url: song.preview_url,
      vote_score: song.vote_score
    }
  end

  def track_json(queue_item)
    {
      id: queue_item.id,
      title: queue_item.song.title,
      artist: queue_item.song.artist,
      cover_url: queue_item.song.cover_url,
      preview_url: queue_item.song.preview_url,
      duration_ms: queue_item.song.duration_ms,
      score: queue_item.score,
      vote_count: queue_item.vote_count
    }
  end

  def queue_item_json(item)
    {
      id: item.id,
      title: item.song.title,
      artist: item.song.artist,
      cover_url: item.song.cover_url,
      preview_url: item.song.preview_url,
      duration_ms: item.song.duration_ms,
      score: item.score,
      vote_count: item.vote_count,
      user: item.user.display_name,
      price: (item.price_for_display_cents.to_f / 100.0).round(2),
      is_currently_playing: item.is_currently_playing
    }
  end

  def currently_playing_json
    now_playing_item = @queue_session.queue_items
                                     .where.not(played_at: nil)
                                     .order(played_at: :desc)
                                     .first

    return nil unless now_playing_item

    # if you want the "song" style payload:
    {
      id: now_playing_item.id,
      title: now_playing_item.title,
      artist: now_playing_item.artist,
      cover_url: now_playing_item.cover_url,
      preview_url: now_playing_item.preview_url,
      played_at: now_playing_item.played_at
    }
  end

  def upcoming_queue_json
    @queue_session.queue_items
                  .where(played_at: nil)
                  .order(vote_score: :desc, created_at: :asc)
                  .map { |item| queue_item_json(item) }
  end
end
